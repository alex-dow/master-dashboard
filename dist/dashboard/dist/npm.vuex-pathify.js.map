{"version":3,"sources":["webpack:////home/v0idnull/Github/master-dashboard/node_modules/vuex-pathify/dist/vuex-pathify.esm.js"],"names":["vuex","store","state","commit","dispatch","ref","args","len","arguments","length","apply","isObject","value","hasKey","obj","key","getKeys","Array","isArray","map","String","Object","keys","match","getValue","path","every","valid","hasOwnProperty","hasValue","shift","clone","JSON","parse","stringify","resolver","options","mapping","strict","cache","deep","formatters","camel","text","replace","c","toUpperCase","join","snake","this","a","b","toLowerCase","const","members","getters","actions","mutations","resolvers","standard","type","name","formatters$$1","simple","resolveName","substr","fn","Error","resolve","modPath","trgName","absPath","split","statePath","objPath","indexOf","pop","_modulesNamespaceMap","module","target","isDynamic","get","member","resName","trgPath","exists","Payload","expr","makeSetter","action","payload","mutation","interpolated","interpolate","makeGetter","stateOnly","getter","getValueIfEnabled","source","console","error","scope","all","token","resolve$1","prototype","update","create","reduce","index","isIndex","test","parseInt","setValue","concat","assign","pathify","plugin","set","setter","copy","accessorize","debug","log","getStateKeys","resolveStates","last","main","substring","rx","RegExp","filter","resolveHandlers","hash","init","makePath","makePathsHash","paths","props","make","getOne","expandGet","sync","syncOne","expandSync","call","callOne","expandCall","_actions","fnHandler","fnResolver","data","prop","makePaths","forEach","setOne","$store","this$1","$nextTick","$emit","createDecorator","Get","computed","Sync","Call","methods","registerModule","callback","beforeCreate","$options","destoyed","unregisterModule"],"mappings":"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","file":"dist/npm.vuex-pathify.js","sourcesContent":["/**\n * Bundle of: vuex-pathify\n * Generated: 2019-12-16\n * Version: 1.4.1\n */\n\nvar vuex = {\n  /**\n   * THIS OBJECT IS REPLACED AT RUNTIME WITH THE ACTUAL VUEX STORE\n   */\n  store: {\n    state: null,\n\n    commit: function commit () {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('[Vuex Pathify] Plugin not initialized!');\n      }\n    },\n\n    dispatch: function dispatch () {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('[Vuex Pathify] Plugin not initialized!');\n      }\n    }\n  }\n};\n\nfunction commit() {\n  var ref;\n\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n  (ref = vuex.store).commit.apply(ref, args);\n}\n\nfunction dispatch() {\n  var ref;\n\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n  return (ref = vuex.store).dispatch.apply(ref, args)\n}\n\n/**\n * Tests whether a passed value is an Object\n *\n * @param   {*}       value   The value to be assessed\n * @returns {boolean}         Whether the value is a true Object\n */\n\n/**\n * Tests whether a passed value is an Object or Array\n *\n * @param   {*}       value   The value to be assessed\n * @returns {boolean}         Whether the value is an Object or Array\n */\nfunction isObject (value) {\n  return !!value && typeof value === 'object'\n}\n\n/**\n * Tests whether a passed value is an Object and has the specified key\n *\n * @param   {Object}   obj    The source object\n * @param   {string}   key    The key to check that exists\n * @returns {boolean}         Whether the predicate is satisfied\n */\nfunction hasKey(obj, key) {\n  return isObject(obj) && key in obj\n}\n\n/**\n * Gets an array of keys from a value\n *\n * The function handles various types:\n *\n * - string - match all words\n * - object - return keys\n * - array  - return a string array of its values\n *\n * @param   {*}       value   The value to get keys from\n * @returns {Array}\n */\nfunction getKeys (value) {\n  return !value\n    ? []\n    : Array.isArray(value)\n      ? value.map(function (key) { return String(key); })\n      : typeof value === 'object'\n        ? Object.keys(value)\n        : typeof value === 'string'\n          ? value.match(/[-$\\w]+/g) || []\n          : []\n}\n\n/**\n * Gets a value from an object, based on a path to the property\n *\n * @param   {Object}                obj     The Object to get the value from\n * @param   {string|Array|Object}  [path]   The optional path to a sub-property\n * @returns {*}\n */\nfunction getValue (obj, path) {\n  var value = obj;\n  var keys = getKeys(path);\n\n  keys.every(function (key) {\n    var valid = isObject(value) && value.hasOwnProperty(key);\n    value = valid ? value[key] : void 0;\n    return valid\n  });\n  return value\n}\n\n/**\n * Sets a value on an object, based on a path to the property\n *\n * @param   {Object}                obj       The Object to set the value on\n * @param   {string|Array|Object}   path      The path to a sub-property\n * @param   {*}                     value     The value to set\n * @param   {boolean}              [create]   Optional flag to create sub-properties; defaults to false\n * @returns {Boolean}                         True or false, depending if value was set\n */\nfunction setValue (obj, path, value, create) {\n  if ( create === void 0 ) create = false;\n\n  var keys = getKeys(path);\n  return keys.reduce(function (obj, key, index)  {\n    var isIndex = /^\\d+$/.test(key);\n    if (isIndex) {\n      key = parseInt(key);\n    }\n    if (!obj) {\n      return false\n    }\n    else if (index === keys.length - 1) {\n      obj[key] = value;\n      return true\n    }\n    else if (!isObject(obj[key]) || !(key in obj)) {\n      if (create) {\n        obj[key] = isIndex ? [] : {};\n      } else {\n        return false\n      }\n    }\n    return obj[key]\n  }, obj)\n}\n\n/**\n * Checks an object has a property, based on a path to the property\n *\n * @param   {Object}                obj     The Object to check the value on\n * @param   {string|Array|Object}   path    The path to a sub-property\n * @returns {boolean}                       Boolean true or false\n */\nfunction hasValue(obj, path) {\n  var keys = getKeys(path);\n  if (isObject(obj)) {\n    while (keys.length) {\n      var key = keys.shift();\n      if (hasKey(obj, key)) {\n        obj = obj[key];\n      } else {\n        return false\n      }\n    }\n    return true\n  }\n  return false\n}\n\nfunction clone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\nvar options = {\n  mapping: 'standard',  // map states to store members using the \"standard\" scheme\n  strict: true,         // throw an error if the store member cannot be found\n  cache: true,          // cache generated functions for faster re-use\n  deep: 1,              // allow sub-property access, but not creation\n};\n\nvar formatters = {\n  camel: function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return args.shift() + args\n      .map(function (text) { return text.replace(/\\w/, function (c) { return c.toUpperCase(); }); })\n      .join('')\n  },\n\n  snake: function () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n    return (ref = this)\n      .camel.apply(ref, args)\n      .replace(/([a-z])([A-Z])/g, function (match, a, b) { return a + '_' + b; })\n      .toLowerCase()\n  },\n\n  const: function () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n    return (ref = this)\n      .snake.apply(ref, args)\n      .toUpperCase()\n  }\n};\n\n/**\n * Map of store members\n */\nvar members = {\n  state: 'state',\n  getters: 'getters',\n  actions: '_actions',\n  mutations: '_mutations',\n};\n\n/**\n * Map of default resolver functions\n */\nvar resolvers = {\n\n  /**\n   * Standard name mapping function\n   *\n   * Adheres to seemingly the most common Vuex naming pattern\n   *\n   * @param   {string}  type          The member type, i.e state, getters, mutations, or actions\n   * @param   {string}  name          The name of the property being targeted, i.e. value\n   * @param   {object}  formatters    A formatters object with common format functions, camel, snake, const\n   * @returns {string}\n   */\n  standard: function standard (type, name, formatters$$1) {\n    switch(type) {\n      case 'mutations':\n        return formatters$$1.const('set', name) // SET_BAR\n      case 'actions':\n        return formatters$$1.camel('set', name) // setBar\n    }\n    return name // bar\n  },\n\n  /**\n   * Simple name mapping function\n   */\n  simple: function simple (type, name, formatters$$1) {\n    if (type === 'actions') {\n      return formatters$$1.camel('set', name) // setBar\n    }\n    return name // bar\n  },\n\n};\n\n/**\n * Configured resolver\n */\nvar resolver;\n\n/**\n * Internal function to resolve member name using configured mapping function\n *\n * @param   {string}  type  The member type, i.e. actions\n * @param   {string}  name  The supplied path member id, i.e. value\n * @returns {string}        The resolved member name, i.e. SET_VALUE\n */\nfunction resolveName (type, name) {\n  // bypass resolver\n  if (name.match(/!$/)) {\n    return name.substr(0, name.length - 1)\n  }\n\n  // configured resolver\n  var fn = resolver;\n\n  // unconfigured resolver! (runs once)\n  if (!fn) {\n    if (typeof options.mapping === 'function') {\n      fn = options.mapping;\n    }\n    else {\n      fn = resolvers[options.mapping];\n      if (!fn) {\n        throw new Error((\"[Vuex Pathify] Unknown mapping '\" + (options.mapping) + \"' in options\\n    - Choose one of '\" + (Object.keys(resolvers).join(\"', '\")) + \"'\\n    - Or, supply a custom function\\n\"))\n      }\n    }\n\n    resolver = fn;\n  }\n\n  // resolve!\n  return resolver(type, name, formatters)\n}\n\n/**\n * Creates a resolver object that caches properties and can resolve store member properties\n *\n * @param   {object}  store     The Vuex store instance\n * @param   {string}  path      A pathify path to the store target, i.e. 'foo/bar@a.b.c'\n * @returns {object}\n */\nfunction resolve (store, path) {\n  // state\n  var absPath = path.replace(/[/@!]+/g, '.');\n\n  // paths\n  var ref = path.split('@');\n  var statePath = ref[0];\n  var objPath = ref[1];\n\n  // parent\n  var modPath, trgName;\n  if (statePath.indexOf('/') > -1) {\n    var keys = statePath.split('/');\n    trgName = keys.pop();\n    modPath = keys.join('/');\n  }\n  else {\n    trgName = statePath;\n  }\n\n  // throw error if module does not exist\n  if (modPath && !store._modulesNamespaceMap[modPath + '/']) {\n    throw new Error((\"[Vuex Pathify] Unknown module '\" + modPath + \"' via path '\" + path + \"'\"))\n  }\n\n  // resolve targets\n  return {\n    absPath: absPath,\n    module: modPath,\n    target: statePath,\n    name: trgName.replace('!', ''),\n    isDynamic: path.indexOf(':') > -1,\n\n    /**\n     * Returns properties about the targeted member\n     *\n     * @param   {string}  type  The member type, i.e state, getters, mutations, or actions\n     * @returns {{exists: boolean, member: object, type: string, path: string}}\n     */\n    get: function (type) {\n      // targeted member, i.e. store._getters\n      var member = store[members[type]];\n\n      // resolved target name, i.e. SET_VALUE\n      var resName = resolveName(type, trgName);\n\n      // target path, i.e. store._getters['module/SET_VALUE']\n      var trgPath = modPath\n        ? modPath + '/' + resName\n        : resName;\n\n      // return values\n      return {\n        exists: type === 'state'\n          ? hasValue(member, trgPath)\n          : trgPath in member,\n        member: member,\n        trgPath: trgPath,\n        trgName: resName,\n        objPath: objPath,\n      }\n    }\n  }\n}\n\n/**\n * Error generation function for accessors\n */\nfunction getError(path, resolver, aName, a, bName, b) {\n  var error = \"[Vuex Pathify] Unable to map path '\" + path + \"':\";\n  if (path.indexOf('!') > -1) {\n    error += \"\\n    - Did not find \" + aName + \" or \" + bName + \" named '\" + (resolver.name) + \"' on \" + (resolver.module ? (\"module '\" + (resolver.module) + \"'\"): 'root store');\n  }\n  else {\n    var aText = a\n      ? (aName + \" '\" + (a.trgName) + \"' or \")\n      : '';\n    var bText = bName + \" '\" + (b.trgName) + \"'\";\n    error += \"\\n    - Did not find \" + aText + bText + \" on \" + (resolver.module ? (\"module '\" + (resolver.module) + \"'\"): 'store') + \"\\n    - Use direct syntax '\" + (resolver.target.replace(/(@|$)/, '!$1')) + \"' (if member exists) to target directly\";\n  }\n  return error\n}\n\n/**\n * Handles passing and setting of sub-property values\n */\nvar Payload = function Payload (expr, path, value) {\n  this.expr = expr;\n  this.path = path;\n  this.value = value;\n};\n\n/**\n * Set sub-property on target\n * @param target\n */\nPayload.prototype.update = function update (target) {\n  if (!options.deep) {\n    console.error((\"[Vuex Pathify] Unable to access sub-property for path '\" + (this.expr) + \"':\\n    - Set option 'deep' to 1 to allow it\"));\n    return target\n  }\n\n  var success = setValue(target, this.path, this.value, options.deep > 1);\n\n  // unable to set sub-property\n  if (!success && process.env.NODE_ENV !== 'production') {\n    console.error((\"[Vuex Pathify] Unable to create sub-property for path '\" + (this.expr) + \"':\\n    - Set option 'deep' to 2 to allow it\"));\n    return target\n  }\n\n  // set sub-property\n  return Array.isArray(target)\n    ? [].concat(target)\n    : Object.assign({}, target)\n};\n\n/**\n * Creates a setter function for the store, automatically targeting actions or mutations\n *\n * Also supports setting of sub-properties as part of the path\n *\n * @see documentation for more detail\n *\n * @param   {Object}  store   The store object\n * @param   {string}  path    The path to the target node\n * @returns {*|Promise}       The return value from the commit() or dispatch()\n */\nfunction makeSetter (store, path) {\n  var resolver = resolve(store, path);\n\n  var action = resolver.get('actions');\n  if (action.exists) {\n    return function (value) {\n      var payload = action.objPath\n        ? new Payload(path, action.objPath, value)\n        : value;\n      return store.dispatch(action.trgPath, payload)\n    }\n  }\n\n  var mutation = resolver.get('mutations');\n  if (mutation.exists || resolver.isDynamic) {\n    return function (value) {\n      // rebuild mutation if using dynamic path\n      if (resolver.isDynamic) {\n        var interpolated = interpolate(path, this);\n        mutation = resolve(store, interpolated).get('mutations');\n      }\n      var payload = mutation.objPath\n        ? new Payload(path, mutation.objPath, value)\n        : value;\n      return store.commit(mutation.trgPath, payload)\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(getError(path, resolver, 'action', action, 'mutation', mutation));\n  }\n\n  return function (value) {}\n}\n\n/**\n * Creates a getter function for the store, automatically targeting getters or state\n *\n * Also supports returning of sub-properties as part of the path\n *\n * @see documentation for more detail\n *\n * @param   {Object}    store       The store object\n * @param   {string}    path        The path to the target node\n * @param   {boolean}  [stateOnly]  An optional flag to get from state only (used when syncing)\n * @returns {*|Function}            The state value or getter function\n */\nfunction makeGetter (store, path, stateOnly) {\n  var resolver = resolve(store, path);\n\n  // for sync, we don't want to read only from state\n  var getter;\n  if (!stateOnly) {\n    getter = resolver.get('getters');\n    if (getter.exists) {\n      return function () {\n        var value = getter.member[getter.trgPath];\n        return getter.objPath\n          ? getValueIfEnabled(path, value, getter.objPath)\n          : value\n      }\n    }\n  }\n\n  var state = resolver.get('state');\n  if (state.exists || resolver.isDynamic) {\n    return function () {\n      var absPath = resolver.isDynamic\n        ? interpolate(resolver.absPath, this)\n        : resolver.absPath;\n      return getValueIfEnabled(path, store.state, absPath)\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(getError(path, resolver, 'getter', getter, 'state', state));\n  }\n\n  return function () {}\n}\n\n/**\n * Utility function to get value from store, but only if options allow\n *\n * @param   {string}  expr    The full path expression\n * @param   {object}  source  The source object to get property from\n * @param   {string}  path    The full dot-path on the source object\n * @returns {*}\n */\nfunction getValueIfEnabled(expr, source, path) {\n  if (!options.deep && expr.indexOf('@') > -1) {\n    console.error((\"[Vuex Pathify] Unable to access sub-property for path '\" + expr + \"':\\n    - Set option 'deep' to 1 to allow it\"));\n    return\n  }\n  return getValue(source, path)\n}\n\n/**\n * Utility function to interpolate a string with properties\n * @param   {string}  path    The path containing interpolation :tokens\n * @param   {object}  scope   The scope containing properties to be used\n * @return  {string}\n */\nfunction interpolate (path, scope) {\n  return path.replace(/:(\\w+)/g, function replace (all, token) {\n    if (!(token in scope)) {\n      console.error((\"Error resolving dynamic store path: The property \\\"\" + token + \"\\\" does not exist on the scope\"), scope);\n    }\n    return scope[token]\n  })\n}\n\nfunction accessorize (store) {\n\n  /**\n   * Set a property on the store, automatically using actions or mutations\n   *\n   * @param   {string}        path    The path to the store member\n   * @param   {*}             value   The value to set\n   * @returns {Promise|*}             Any return value from the action / commit\n   */\n  store.set = function (path, value) {\n    var setter = makeSetter(store, path);\n    if (typeof setter !== 'undefined') {\n      return setter(value)\n    }\n  };\n\n  /**\n   * Get a property from the store, automatically using getters or state\n   *\n   * @param   {string}        path    The path to the store member\n   * @param   {*}             args    Optional getter function parameters\n   * @returns {*|undefined}           The state value / getter value / getter function / or undefined\n   */\n  store.get = function (path) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    var getter = makeGetter(store, path);\n    if (typeof getter !== 'undefined') {\n      var value = getter();\n      return typeof value === 'function'\n        ? value.apply(void 0, args)\n        : value\n    }\n  };\n\n  /**\n   * Get a copy of a property from the store, automatically using actions or mutations\n   *\n   * @param   {string}        path    The path to the store member\n   * @param   {*}             args    Optional getter function parameters\n   * @returns {*|undefined}           The value, or undefined\n   */\n  store.copy = function (path) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    var value = store.get.apply(store, [ path ].concat( args ));\n    return isObject(value)\n      ? clone(value)\n      : value\n  };\n}\n\nfunction resolve$1 (type) {\n  return resolveName(type, 'value')\n}\n\nfunction debug () {\n  console.log((\"\\n  [Vuex Pathify] Options:\\n\\n  Mapping (\" + (typeof options.mapping === 'function' ? 'custom' : options.mapping) + \")\\n-------------------------------\\n  path       : value\\n  state      : \" + (resolve$1('state')) + \"\\n  getters    : \" + (resolve$1('getters')) + \"\\n  actions    : \" + (resolve$1('actions')) + \"\\n  mutations  : \" + (resolve$1('mutations')) + \"\\n\\n  Settings\\n-------------------------------\\n  strict     : \" + (options.strict) + \"\\n  cache      : \" + (options.cache) + \"\\n  deep       : \" + (options.deep) + \"\\n\\n\"));\n}\n\n// plugin\n\n/**\n * Store plugin which updates the store object with set() and get() methods\n *\n * @param {Object} store  The store object\n */\nfunction plugin (store) {\n\n  // cache store instance\n  vuex.store = store;\n\n  // add pathify accessors\n  accessorize(store);\n}\n\nvar pathify = {\n  options: options,\n  plugin: plugin,\n  debug: debug,\n};\n\n/**\n * Utility function to grab keys for state\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n * @returns {Array}\n */\nfunction getStateKeys (state) {\n  return getKeys(typeof state === 'function' ? state() : state)\n}\n\n/**\n * Helper function to mass-create default getter functions for an existing state object\n *\n * Note that you don't need to create top-level getter functions if using $store.get(...)\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n */\nfunction makeGetters (state) {\n  return getStateKeys(state)\n    .reduce(function (obj, key) {\n      var getter = resolveName('getters', key);\n      obj[getter] = function (state) {\n        return state[key]\n      };\n      return obj\n    }, {})\n}\n\n/**\n * Helper function to mass-create default mutation functions for an existing state object\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n */\nfunction makeMutations (state) {\n  return getStateKeys(state)\n    .reduce(function (obj, key) {\n      var mutation = resolveName('mutations', key);\n      obj[mutation] = function (state, value) {\n        state[key] = value instanceof Payload\n          ? value.update(state[key])\n          : value;\n      };\n      return obj\n    }, {})\n}\n\n/**\n * Helper function to mass-create default actions functions for an existing state object\n *\n * @param   {Object|Function|Array|String}   state   State object, state function, array or string of key names\n */\nfunction makeActions (state) {\n  return getStateKeys(state)\n    .reduce(function (obj, key) {\n      var action = resolveName('actions', key);\n      var mutation = resolveName('mutations', key);\n      obj[action] = function (ref, value) {\n        var commit = ref.commit;\n\n        commit(mutation, value);\n      };\n      return obj\n    }, {})\n}\n\nvar store = {\n  getters: makeGetters,\n  mutations: makeMutations,\n  actions: makeActions,\n};\n\n// -------------------------------------------------------------------------------------------------------------------\n// external\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Utility function to expand wildcard path for get()\n *\n * @param   {string}        path        wildcard path\n * @param   {object}        state       state hash\n * @param   {object}        getters     getters hash\n * @returns {array|string}\n */\nfunction expandGet (path, state, getters) {\n  if (!init(path, state)) {\n    return ''\n  }\n  return resolveStates(path, state).concat( resolveHandlers(path, getters) )\n}\n\n/**\n * Utility function to expand wildcard path for sync()\n *\n * @param   {string}        path        wildcard path\n * @param   {object}        state       state hash\n * @returns {array|string}\n */\nfunction expandSync (path, state) {\n  if (!init(path, state)) {\n    return ''\n  }\n  return resolveStates(path, state)\n}\n\n/**\n * Utility function to expand wildcard path for actions()\n *\n * @param   {string}        path        wildcard path\n * @param   {object}        actions     actions hash\n * @returns {array|string}\n */\nfunction expandCall (path, actions) {\n  if (!init(path, actions)) {\n    return ''\n  }\n  return resolveHandlers(path, actions)\n}\n\n\n// -------------------------------------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Helper function to resolve state properties from a wildcard path\n *\n * Note: this function traverses into the state object and any properties / sub-properties\n *\n * @param   {string}    path    A path with a wildcard at the end\n * @param   {object}    state   A state object on which to look up the sub-properties\n * @returns {string[]}          An array of paths\n */\nfunction resolveStates (path, state) {\n  // grab segments\n  var last = path.match(/([^/@\\.]+)$/)[1];\n  var main = path.substring(0, path.length - last.length);\n  var keys = main.replace(/\\W+$/, '').split(/[/@.]/);\n\n  // find state parent\n  var obj = main\n    ? getValue(state, keys)\n    : state;\n  if (!obj) {\n    console.error((\"[Vuex Pathify] Unable to expand wildcard path '\" + path + \"':\\n    - It looks like '\" + (main.replace(/\\W+$/, '')) + \"' does not resolve to an existing state property\"));\n    return []\n  }\n\n  // filter children\n  var rx = new RegExp('^' + last.replace(/\\*/g, '\\\\w+') + '$');\n  return Object\n    .keys(obj)\n    .filter(function (key) { return rx.test(key); })\n    .map(function (key) { return main + key; })\n}\n\n/**\n * Helper function to resolve getters, actions or mutations from a wildcard path\n *\n * Note: this function filters the top-level flat hash of members\n *\n * @param   {string}    path      A path with a wildcard at the end\n * @param   {object}    hash      A hash on which to filter by key => wildcard\n * @returns {string[]}            An array of paths\n */\nfunction resolveHandlers (path, hash) {\n  var rx = new RegExp('^' + path.replace(/\\*/g, '\\\\w+') + '$');\n  return Object.keys(hash).filter(function (key) { return rx.test(key); })\n}\n\n\n// -------------------------------------------------------------------------------------------------------------------\n// utility\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Pre-flight check for wildcard paths\n *\n * @param   {string}  path\n * @param   {object}  state\n * @returns {boolean}\n */\nfunction init (path, state) {\n  // only wildcards in final path segment are supported\n  if (path.indexOf('*') > -1 && /\\*.*[/@.]/.test(path)) {\n    console.error((\"[Vuex Pathify] Invalid wildcard placement for path '\" + path + \"':\\n    - Wildcards may only be used in the last segment of a path\"));\n    return false\n  }\n\n  // edge case where store sometimes doesn't exist\n  if (!state) {\n    console.error((\"[Vuex Pathify] Unable to expand wildcard path '\" + path + \"':\\n    - The usual reason for this is that the router was set up before the store\\n    - Make sure the store is imported before the router, then reload\"));\n    return false\n  }\n\n  return true\n}\n\n/**\n * Helper function to convert Pathify path syntax paths to objects\n *\n * Handles:\n *\n * - string path\n * - object and array formats\n * - path + object/array format\n * - wildcards in path\n *\n * Returns a single string, or hash of key => paths\n *\n * @param   {string|object|array}  [path]       An optional path prefix\n * @param   {object}                props       An optional hash or array of paths / segments\n * @param   {function}              fnResolver  A function to resolve wildcards\n * @returns {object|string}\n */\nfunction makePaths (path, props, fnResolver) {\n  // handle wildcards\n  if (typeof path === 'string' && path.indexOf('*') > -1) {\n    return makePathsHash(fnResolver(path))\n  }\n\n  // handle array as path\n  if (Array.isArray(path)) {\n    return makePathsHash(path)\n  }\n\n  // handle object as path\n  if (isObject(path)) {\n    props = path;\n    path = '';\n  }\n\n  // if props is an array\n  if (Array.isArray(props)) {\n    var paths = props\n      .map(function (prop) {\n        return makePath(path, prop)\n      });\n    return makePathsHash(paths)\n  }\n\n  // if props is an object\n  if (isObject(props)) {\n    return Object\n      .keys(props)\n      .reduce(function (paths, key) {\n        paths[key] = makePath(path, props[key]);\n        return paths\n      }, {})\n  }\n\n  // if path is a single string without wildcards\n  return path\n}\n\n/**\n * Helper function to concatenate two path components into a valid path\n *\n * Handles one or no \"/\" \"@\" or '.' characters in either string\n *\n * @param   {string}  path\n * @param   {string}  target\n * @returns {string}\n */\nfunction makePath (path, target) {\n  if ( target === void 0 ) target = '';\n\n  path = path.replace(/\\/+$/, '');\n  var value = path.indexOf('@') > -1\n    ? path + '.' + target\n    : path + '/' + target;\n  return value\n    .replace(/^\\/|[.@/]+$/, '')\n    .replace(/\\/@/, '@')\n    .replace(/@\\./, '@')\n}\n\n/**\n * Helper function to convert an array of paths to a hash\n *\n * Uses the last path segment as the key\n *\n * @param   {string[]}  paths   An array of paths to convert to a hash\n * @returns {object}            A hash of paths\n */\nfunction makePathsHash (paths) {\n  return paths.reduce(function (paths, path) {\n    var key = path.match(/\\w+$/);\n    paths[key] = path;\n    return paths\n  }, {})\n}\n\n// -------------------------------------------------------------------------------------------------------------------\n// entry\n// -------------------------------------------------------------------------------------------------------------------\n\nfunction get (path, props) {\n  return make(path, props, getOne, function (path) {\n    return expandGet(path, vuex.store.state, vuex.store.getters)\n  })\n}\n\nfunction sync (path, props) {\n  return make(path, props, syncOne, function (path) {\n    return expandSync(path, vuex.store.state)\n  })\n}\n\nfunction call (path, props) {\n  return make(path, props, callOne, function (path) {\n    return expandCall(path, vuex.store._actions)\n  })\n}\n\n\n// -------------------------------------------------------------------------------------------------------------------\n// utility\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Creates multiple 2-way vue:vuex computed properties\n *\n * The function has multiple usages:\n *\n *  1. multiple properties from multiple modules\n *\n *     - @usage                                 ...sync({foo: 'module1/foo', bar: 'module2/bar'})\n *\n *     - @param   {Object}          props       a hash of key:path state/getter or commit/action references\n *\n *  2. multiple properties from a single module (object shorthand)\n *\n *     - @usage                                 ...sync('module', {foo: 'foo', bar: 'bar'})\n *\n *     - @param   {string}          path        a path to a module\n *     - @param   {Object}          props       a hash of key:prop state/getter or commit/action references\n *\n *  3. multiple properties from a single module (array shorthand)\n *\n *     - @usage                                 ...sync('module', ['foo', 'bar'])\n *\n *     - @param   {string}          path        a path to a module\n *     - @param   {Array}           props       an Array of state/getter or commit/action references\n *\n * Where different getter / setters need to be specified, pass getter and setter in\n * the same string, separating with a | character:\n *\n *     - @usage                                 ...sync('module', ['foo|updateFoo'])\n *\n * @param   {string|Object}         path        a path to a module, or a hash of state/getter or commit/action references\n * @param   {Object|Array}          props       a hash of state/getter or commit/action references\n * @param   {Function}              fnHandler   a callback function to create the handler\n * @param   {Function}              fnResolver\n * @returns {{set, get}}                        a hash of Objects\n */\nfunction make (path, props, fnHandler, fnResolver) {\n  // expand path / props\n  var data = makePaths(path, props, fnResolver);\n\n  // handle single paths\n  if (typeof data === 'string') {\n    return fnHandler(data)\n  }\n\n  // handle multiple properties\n  Object\n    .keys(data)\n    .forEach(function (key) {\n      data[key] = fnHandler(data[key]);\n    });\n  return data\n}\n\n// -------------------------------------------------------------------------------------------------------------------\n// one\n// -------------------------------------------------------------------------------------------------------------------\n\n/**\n * Creates a single 2-way vue:vuex computed property\n *\n * @param   {string}      path      a path to a state/getter reference. Path can contain an optional commit / action reference, separated by a |, i.e. foo/bar|updateBar\n * @returns {Object}                a single get/set Object\n */\nfunction syncOne (path) {\n  var ref = path.split('|');\n  var getter = ref[0];\n  var setter = ref[1];\n  if (setter) {\n    setter = getter.replace(/\\w+!?$/, setter.replace('!', '') + '!');\n  }\n  return getter && setter\n    ? { get: getOne(getter, true), set: setOne(setter) }\n    : { get: getOne(getter, true), set: setOne(getter) }\n}\n\n/**\n * Creates a single 1-way vue:vuex computed getter\n *\n * @param   {string}      path          A path to a state/getter reference\n * @param   {boolean}    [stateOnly]    An optional flag to get from state only (used when syncing)\n * @returns {Object}                    A single getter function\n */\nfunction getOne (path, stateOnly) {\n  var getter, store;\n  return function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    if (!this.$store) {\n      throw new Error('[Vuex Pathify] Unexpected condition: this.$store is undefined.\\n\\nThis is a known edge case with some setups and will cause future lookups to fail')\n    }\n    if (!getter || store !== this.$store) {\n      store = this.$store;\n      getter = makeGetter(store, path, stateOnly);\n    }\n    return getter.call.apply(getter, [ this ].concat( args ))\n  }\n}\n\n/**\n * Creates a single 1-way vue:vuex setter\n *\n * @param   {string}      path      a path to an action/commit reference\n * @returns {Function}              a single setter function\n */\nfunction setOne (path) {\n  var setter, store;\n  return function (value) {\n    var this$1 = this;\n\n    if (!setter || store !== this.$store) {\n      store = this.$store;\n      setter = makeSetter(store, path);\n    }\n    this.$nextTick(function () { return this$1.$emit('sync', path, value); });\n    return setter.call(this, value)\n  }\n}\n\n/**\n * Creates a single action dispatcher\n *\n * @param   {string}      path      a path to an action/commit reference\n * @returns {Function}              a single setter function\n */\nfunction callOne (path) {\n  return function (value) {\n    return this.$store.dispatch(path, value)\n  }\n}\n\n/**\n * @module\n * @description Decorators for Vuex Pathify component helpers\n *\n * For example:\n * ```js\n * @Component\n * class MyComponent extends Vue {\n *   @Get('name')\n *   @Set('name')\n *   @Call('setName')\n * }\n * ```\n */\n\nvar createDecorator = require('vue-class-component').createDecorator;\n\n/**\n * Decorator for `get` component helper.\n * @param   {string}          path    The path to store property\n * @returns {VueDecorator}            Vue decorator to be used in Vue class component.\n */\nfunction Get (path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can only be used for single property access') }\n  return createDecorator(function (options, key) {\n    if (!options.computed) { options.computed = {}; }\n    options.computed[key] = get(path);\n  })\n}\n\n/**\n * Decorator for `sync` component helper.\n * @param   {string}          path    The path to store property\n * @returns {VueDecorator}            Vue decorator to be used in Vue class component.\n */\nfunction Sync (path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can only be used for single property access') }\n  return createDecorator(function (options, key) {\n    if (!options.computed) { options.computed = {}; }\n    options.computed[key] = sync(path);\n  })\n}\n\n/**\n * Decorator for `call` component helper.\n * @param   {string}          path    The path to store property\n * @returns {VueDecorator}            Vue decorator to be used in Vue class component.\n */\nfunction Call (path) {\n  if (typeof path !== 'string' || arguments.length > 1) { throw new Error('Property decorators can only be used for single property access') }\n  return createDecorator(function (options, key) {\n    if (!options.methods) { options.methods = {}; }\n    options.methods[key] = call(path);\n  })\n}\n\n/**\n * Helper function to generate a mixin that registers module and computed properties on component creation\n *\n * @param   {string|Array}  path        The path to register the Vuex module on\n * @param   {object}        module      The module definition to register when the\n * @param   {function}      callback    A callback returning store members to be added to the component definition\n * @param   {object}       [options]    Optional Vuex module registration options\n * @returns {object}                    The mixin\n */\nfunction registerModule(path, module, callback, options) {\n  return {\n    beforeCreate: function beforeCreate () {\n      this.$store.registerModule(path, module, options);\n      var members = callback();\n      this.$options.computed = Object.assign(this.$options.computed || {}, members.computed || {});\n      this.$options.methods = Object.assign(this.$options.methods || {}, members.methods || {});\n    },\n\n    destoyed: function destoyed () {\n      this.$store.unregisterModule(path);\n    }\n  }\n}\n\nexport default pathify;\nexport { store as make, Payload, get, sync, call, Get, Sync, Call, commit, dispatch, registerModule };\n"],"sourceRoot":""}