{"version":3,"sources":["webpack:////home/v0idnull/Github/master-dashboard/node_modules/fast-xml-parser/src/node2json.js","webpack:////home/v0idnull/Github/master-dashboard/node_modules/fast-xml-parser/src/xmlNode.js","webpack:////home/v0idnull/Github/master-dashboard/node_modules/fast-xml-parser/src/validator.js","webpack:////home/v0idnull/Github/master-dashboard/node_modules/fast-xml-parser/src/nimndata.js","webpack:////home/v0idnull/Github/master-dashboard/node_modules/fast-xml-parser/src/node2json_str.js","webpack:////home/v0idnull/Github/master-dashboard/node_modules/fast-xml-parser/src/json2xml.js","webpack:////home/v0idnull/Github/master-dashboard/node_modules/fast-xml-parser/src/xmlstr2xmlnode.js","webpack:////home/v0idnull/Github/master-dashboard/node_modules/fast-xml-parser/src/util.js","webpack:////home/v0idnull/Github/master-dashboard/node_modules/fast-xml-parser/src/parser.js"],"names":["util","convertToJson","node","options","jObj","child","isEmptyObject","attrsMap","isExist","val","cdataPositionChar","arrayMode","textNodeName","merge","keys","Object","index","length","tagname","tag","push","result","exports","module","parent","this","addChild","Array","isArray","defaultOptions","allowBooleanAttributes","localeRange","props","readPI","xmlData","i","start","substr","getErrorObject","getLineNumberForPosition","readCommentAndCDATA","angleBracketsCount","validate","buildOptions","RegExp","test","tags","tagFound","reachedRoot","regxAttrName","regxTagName","err","closingTag","tagName","trim","substring","validateTagName","msg","readAttributeStr","attrStr","value","isValid","validateAttributeString","code","line","tagClosed","otg","pop","JSON","stringify","replace","doubleQuote","singleQuote","startChar","validAttrStrRegxp","matches","getAllMatches","attrNames","getPositionFromMatch","undefined","attrName","validateAttrName","hasOwnProperty","message","lineNumber","doesMatch","doesNotMatch","split","match","indexOf","char","a","String","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","objStart","arrStart","arrayEnd","charsArr","_e","e_schema","getValue","hasValidData","str","itemSchema","arr_len","arr_i","r","processValue","key","ignoreAttributes","isAppChar","ch","x2j","convert2nimn","_cToJsonStr","level","v","isNaN","convertToJsonString","indentBy","attributeNamePrefix","attrNodeName","cdataTagName","format","supressEmptyNode","tagValueProcessor","attrValueProcessor","Parser","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","cdata","join","includes","repeat","name","startsWith","prototype","parse","j2x","len","Date","attr","arrLen","j","item","Ks","L","xmlNode","TagType","OPENING","CLOSING","SELF","CDATA","regx","Number","parseInt","window","parseFloat","ignoreNameSpace","parseNodeValue","parseAttributeValue","trimValues","stopNodes","processTagValue","parsedTags","parentTagName","parseValue","parseTrueNumberOnly","checkForTagType","resolveNameSpace","prefix","charAt","shouldParse","parsed","attrsRegx","buildAttributesMap","attrs","attrCollection","getTraversalObj","xmlObj","currentNode","tagsRegx","exec","nextTag","tagType","startIndex","childNode","string","regex","obj","target","newOptions","allmatches","nodeToJson","xmlToNodeobj","x2xmlnode","validator","validationOption","Error","convertTonimn","j2xParser","parseToNimn","schema"],"mappings":"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","file":"dist/npm.fast-xml-parser.js","sourcesContent":["'use strict';\n\nconst util = require('./util');\n\nconst convertToJson = function(node, options) {\n  const jObj = {};\n\n  //when no child node or attr is present\n  if ((!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  } else {\n    //otherwise create a textnode if node has some text\n    if (util.isExist(node.val)) {\n      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n        if(options.arrayMode === \"strict\"){\n          jObj[options.textNodeName] = [ node.val ];\n        }else{\n          jObj[options.textNodeName] = node.val;\n        }\n      }\n    }\n  }\n\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    var tagname = keys[index];\n    if (node.child[tagname] && node.child[tagname].length > 1) {\n      jObj[tagname] = [];\n      for (var tag in node.child[tagname]) {\n        jObj[tagname].push(convertToJson(node.child[tagname][tag], options));\n      }\n    } else {\n      if(options.arrayMode === true){\n        const result = convertToJson(node.child[tagname][0], options)\n        if(typeof result === 'object')\n          jObj[tagname] = [ result ];\n        else\n          jObj[tagname] = result;\n      }else if(options.arrayMode === \"strict\"){\n        jObj[tagname] = [convertToJson(node.child[tagname][0], options) ];\n      }else{\n        jObj[tagname] = convertToJson(node.child[tagname][0], options);\n      }\n    }\n  }\n\n  //add value\n  return jObj;\n};\n\nexports.convertToJson = convertToJson;\n","'use strict';\n\nmodule.exports = function(tagname, parent, val) {\n  this.tagname = tagname;\n  this.parent = parent;\n  this.child = {}; //child tags\n  this.attrsMap = {}; //attributes map\n  this.val = val; //text only\n  this.addChild = function(child) {\n    if (Array.isArray(this.child[child.tagname])) {\n      //already presents\n      this.child[child.tagname].push(child);\n    } else {\n      this.child[child.tagname] = [child];\n    }\n  };\n};\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  localeRange: 'a-zA-Z',\n};\n\nconst props = ['allowBooleanAttributes', 'localeRange'];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = util.buildOptions(options, defaultOptions, props);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const localRangeRegex = new RegExp(`[${options.localeRange}]`);\n\n  if (localRangeRegex.test(\"<#$'\\\"\\\\\\/:0\")) {\n    return getErrorObject('InvalidOptions', 'Invalid localeRange', 1);\n  }\n\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  const regxAttrName = new RegExp(`^[${options.localeRange}_][${options.localeRange}0-9\\\\-\\\\.:]*$`);\n  const regxTagName = new RegExp(`^([${options.localeRange}_])[${options.localeRange}0-9\\\\.\\\\-_:]*$`);\n  for (let i = 0; i < xmlData.length; i++) {\n    if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n\n      i++;\n      if (xmlData[i] === '?') {\n        i = readPI(xmlData, ++i);\n        if (i.err) {\n          return i;\n        }\n      } else if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (\n          ;\n          i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r';\n          i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName, regxTagName)) {\n          let msg;\n          if(tagName.trim().length === 0) {\n            msg = \"There is an unnecessary space between tag name and backward slash '</ ..'.\";\n          }else{\n            msg = `Tag '${tagName}' is an invalid name.`;\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', `Attributes for '${tagName}' have open quote.`, getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options, regxAttrName);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', `Closing tag '${tagName}' doesn't have proper closing.`, getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', `Closing tag '${tagName}' can't have attributes or invalid starting.`, getLineNumberForPosition(xmlData, i));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg) {\n              return getErrorObject('InvalidTag', `Closing tag '${otg}' is expected inplace of '${tagName}'.`, getLineNumberForPosition(xmlData, i));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if(tags.length == 0)\n            {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options, regxAttrName);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if(reachedRoot === true) {\n              return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else {\n              tags.push(tagName);\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else {\n              break;\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if (xmlData[i] === ' ' || xmlData[i] === '\\t' || xmlData[i] === '\\n' || xmlData[i] === '\\r') {\n        continue;\n      }\n      return getErrorObject('InvalidChar', `char '${xmlData[i]}' is not expected.`, getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  } else if (tags.length > 0) {\n    return getErrorObject('InvalidXml', `Invalid '${JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, '')}' found.`, 1);\n  }\n\n  return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  var start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      var tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nvar doubleQuote = '\"';\nvar singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n        continue;\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return { value: attrStr, index: i, tagClosed: tagClosed };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options, regxAttrName) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', `Attribute '${matches[i][2]}' has no space in starting.`, getPositionFromMatch(attrStr, matches[i][0]))\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', `boolean attribute '${matches[i][2]}' is not allowed.`, getPositionFromMatch(attrStr, matches[i][0]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName, regxAttrName)) {\n      return getErrorObject('InvalidAttr', `Attribute '${attrName}' is an invalid name.`, getPositionFromMatch(attrStr, matches[i][0]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', `Attribute '${attrName}' is repeated.`, getPositionFromMatch(attrStr, matches[i][0]));\n    }\n  }\n\n  return true;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber,\n    },\n  };\n}\n\nfunction validateAttrName(attrName, regxAttrName) {\n  // const validAttrRegxp = new RegExp(regxAttrName);\n  return util.doesMatch(attrName, regxAttrName);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\n//  startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname, regxTagName) {\n  /*if(util.doesMatch(tagname,startsWithXML)) return false;\n    else*/\n  //return !tagname.toLowerCase().startsWith(\"xml\") || !util.doesNotMatch(tagname, regxTagName);\n  return !util.doesNotMatch(tagname, regxTagName);\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  var lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return lines.length;\n}\n\n//this function returns the position of the last character of match within attrStr\nfunction getPositionFromMatch(attrStr, match) {\n  return attrStr.indexOf(match) + match.length;\n}","'use strict';\nconst char = function(a) {\n  return String.fromCharCode(a);\n};\n\nconst chars = {\n  nilChar: char(176),\n  missingChar: char(201),\n  nilPremitive: char(175),\n  missingPremitive: char(200),\n\n  emptyChar: char(178),\n  emptyValue: char(177), //empty Premitive\n\n  boundryChar: char(179),\n\n  objStart: char(198),\n  arrStart: char(204),\n  arrayEnd: char(185),\n};\n\nconst charsArr = [\n  chars.nilChar,\n  chars.nilPremitive,\n  chars.missingChar,\n  chars.missingPremitive,\n  chars.boundryChar,\n  chars.emptyChar,\n  chars.emptyValue,\n  chars.arrayEnd,\n  chars.objStart,\n  chars.arrStart,\n];\n\nconst _e = function(node, e_schema, options) {\n  if (typeof e_schema === 'string') {\n    //premitive\n    if (node && node[0] && node[0].val !== undefined) {\n      return getValue(node[0].val, e_schema);\n    } else {\n      return getValue(node, e_schema);\n    }\n  } else {\n    const hasValidData = hasData(node);\n    if (hasValidData === true) {\n      let str = '';\n      if (Array.isArray(e_schema)) {\n        //attributes can't be repeated. hence check in children tags only\n        str += chars.arrStart;\n        const itemSchema = e_schema[0];\n        //var itemSchemaType = itemSchema;\n        const arr_len = node.length;\n\n        if (typeof itemSchema === 'string') {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = getValue(node[arr_i].val, itemSchema);\n            str = processValue(str, r);\n          }\n        } else {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = _e(node[arr_i], itemSchema, options);\n            str = processValue(str, r);\n          }\n        }\n        str += chars.arrayEnd; //indicates that next item is not array item\n      } else {\n        //object\n        str += chars.objStart;\n        const keys = Object.keys(e_schema);\n        if (Array.isArray(node)) {\n          node = node[0];\n        }\n        for (let i in keys) {\n          const key = keys[i];\n          //a property defined in schema can be present either in attrsMap or children tags\n          //options.textNodeName will not present in both maps, take it's value from val\n          //options.attrNodeName will be present in attrsMap\n          let r;\n          if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n            r = _e(node.attrsMap[key], e_schema[key], options);\n          } else if (key === options.textNodeName) {\n            r = _e(node.val, e_schema[key], options);\n          } else {\n            r = _e(node.child[key], e_schema[key], options);\n          }\n          str = processValue(str, r);\n        }\n      }\n      return str;\n    } else {\n      return hasValidData;\n    }\n  }\n};\n\nconst getValue = function(a /*, type*/) {\n  switch (a) {\n    case undefined:\n      return chars.missingPremitive;\n    case null:\n      return chars.nilPremitive;\n    case '':\n      return chars.emptyValue;\n    default:\n      return a;\n  }\n};\n\nconst processValue = function(str, r) {\n  if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n    str += chars.boundryChar;\n  }\n  return str + r;\n};\n\nconst isAppChar = function(ch) {\n  return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n  if (jObj === undefined) {\n    return chars.missingChar;\n  } else if (jObj === null) {\n    return chars.nilChar;\n  } else if (\n    jObj.child &&\n    Object.keys(jObj.child).length === 0 &&\n    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)\n  ) {\n    return chars.emptyChar;\n  } else {\n    return true;\n  }\n}\n\nconst x2j = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n  return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n","'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst x2j = require('./xmlstr2xmlnode');\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n\n  options.indentBy = options.indentBy || '';\n  return _cToJsonStr(node, options, 0);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n  let jObj = '{';\n\n  //traver through all the children\n  const keys = Object.keys(node.child);\n\n  for (let index = 0; index < keys.length; index++) {\n    var tagname = keys[index];\n    if (node.child[tagname] && node.child[tagname].length > 1) {\n      jObj += '\"' + tagname + '\" : [ ';\n      for (var tag in node.child[tagname]) {\n        jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';\n      }\n      jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last\n    } else {\n      jObj += '\"' + tagname + '\" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';\n    }\n  }\n  util.merge(jObj, node.attrsMap);\n  //add attrsMap as new children\n  if (util.isEmptyObject(jObj)) {\n    return util.isExist(node.val) ? node.val : '';\n  } else {\n    if (util.isExist(node.val)) {\n      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n        jObj += '\"' + options.textNodeName + '\" : ' + stringval(node.val);\n      }\n    }\n  }\n  //add value\n  if (jObj[jObj.length - 1] === ',') {\n    jObj = jObj.substr(0, jObj.length - 2);\n  }\n  return jObj + '}';\n};\n\nfunction stringval(v) {\n  if (v === true || v === false || !isNaN(v)) {\n    return v;\n  } else {\n    return '\"' + v + '\"';\n  }\n}\n\nfunction indentate(options, level) {\n  return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;\n","'use strict';\n//parse Empty Node as self closing node\nconst buildOptions = require('./util').buildOptions;\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  format: false,\n  indentBy: '  ',\n  supressEmptyNode: false,\n  tagValueProcessor: function(a) {\n    return a;\n  },\n  attrValueProcessor: function(a) {\n    return a;\n  },\n};\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'cdataTagName',\n  'cdataPositionChar',\n  'format',\n  'indentBy',\n  'supressEmptyNode',\n  'tagValueProcessor',\n  'attrValueProcessor',\n];\n\nfunction Parser(options) {\n  this.options = buildOptions(options, defaultOptions, props);\n  if (this.options.ignoreAttributes || this.options.attrNodeName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n  if (this.options.cdataTagName) {\n    this.isCDATA = isCDATA;\n  } else {\n    this.isCDATA = function(/*a*/) {\n      return false;\n    };\n  }\n  this.replaceCDATAstr = replaceCDATAstr;\n  this.replaceCDATAarr = replaceCDATAarr;\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n\n  if (this.options.supressEmptyNode) {\n    this.buildTextNode = buildEmptyTextNode;\n    this.buildObjNode = buildEmptyObjNode;\n  } else {\n    this.buildTextNode = buildTextValNode;\n    this.buildObjNode = buildObjectNode;\n  }\n\n  this.buildTextValNode = buildTextValNode;\n  this.buildObjectNode = buildObjectNode;\n}\n\nParser.prototype.parse = function(jObj) {\n  return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  const keys = Object.keys(jObj);\n  const len = keys.length;\n  for (let i = 0; i < len; i++) {\n    const key = keys[i];\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node\n    } else if (jObj[key] === null) {\n      val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += ' ' + attr + '=\"' + this.options.attrValueProcessor('' + jObj[key]) + '\"';\n      } else if (this.isCDATA(key)) {\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAstr('', jObj[key]);\n        }\n      } else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          if (jObj[this.options.cdataTagName]) {\n            //value will added while processing cdata\n          } else {\n            val += this.options.tagValueProcessor('' + jObj[key]);\n          }\n        } else {\n          val += this.buildTextNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      if (this.isCDATA(key)) {\n        val += this.indentate(level);\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAarr('', jObj[key]);\n        }\n      } else {\n        //nested nodes\n        const arrLen = jObj[key].length;\n        for (let j = 0; j < arrLen; j++) {\n          const item = jObj[key][j];\n          if (typeof item === 'undefined') {\n            // supress undefined node\n          } else if (item === null) {\n            val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          } else if (typeof item === 'object') {\n            const result = this.j2x(item, level + 1);\n            val += this.buildObjNode(result.val, key, result.attrStr, level);\n          } else {\n            val += this.buildTextNode(item, key, '', level);\n          }\n        }\n      }\n    } else {\n      //nested node\n      if (this.options.attrNodeName && key === this.options.attrNodeName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += ' ' + Ks[j] + '=\"' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '\"';\n        }\n      } else {\n        const result = this.j2x(jObj[key], level + 1);\n        val += this.buildObjNode(result.val, key, result.attrStr, level);\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nfunction replaceCDATAstr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;\n  } else {\n    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);\n  }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;\n  } else {\n    for (let v in cdata) {\n      str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');\n    }\n    return str + this.newLine;\n  }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && !val.includes('<')) {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      '>' +\n      val +\n      //+ this.newLine\n      // + this.indentate(level)\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  } else {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      this.tagEndChar +\n      val +\n      //+ this.newLine\n      this.indentate(level) +\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  }\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n    //+ this.newLine\n  }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n  return (\n    this.indentate(level) +\n    '<' +\n    key +\n    attrStr +\n    '>' +\n    this.options.tagValueProcessor(val) +\n    '</' +\n    key +\n    this.tagEndChar\n  );\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildTextValNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n  }\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix)) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nfunction isCDATA(name) {\n  return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n","'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst TagType = {OPENING: 1, CLOSING: 2, SELF: 3, CDATA: 4};\nlet regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))([^>]*)>|((\\\\/)(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))\\\\s*>))([^<]*)';\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  localeRange: '',\n  tagValueProcessor: function(a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function(a, attrName) {\n    return a;\n  },\n  stopNodes: []\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'localeRange',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'stopNodes'\n];\nexports.props = props;\n\nconst getTraversalObj = function(xmlData, options) {\n  options = buildOptions(options, defaultOptions, props);\n  //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n  xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, ''); //Remove  comments\n\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n\n  regx = regx.replace(/\\[\\\\w/g, '[' + options.localeRange + '\\\\w');\n  const tagsRegx = new RegExp(regx, 'g');\n  let tag = tagsRegx.exec(xmlData);\n  let nextTag = tagsRegx.exec(xmlData);\n  while (tag) {\n    const tagType = checkForTagType(tag);\n\n    if (tagType === TagType.CLOSING) {\n      //add parsed data to parent node\n      if (currentNode.parent && tag[14]) {\n        currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue(tag, options, currentNode.parent.tagname);\n      }\n      if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n        currentNode.child = []\n        if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}\n        currentNode.val = xmlData.substr(currentNode.startIndex + 1, tag.index - currentNode.startIndex - 1)\n      }\n      currentNode = currentNode.parent;\n    } else if (tagType === TagType.CDATA) {\n      if (options.cdataTagName) {\n        //add cdata node\n        const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);\n        childNode.attrsMap = buildAttributesMap(tag[8], options);\n        currentNode.addChild(childNode);\n        //for backtracking\n        currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n        //add rest value to parent node\n        if (tag[14]) {\n          currentNode.val += processTagValue(tag, options);\n        }\n      } else {\n        currentNode.val = (currentNode.val || '') + (tag[3] || '') + processTagValue(tag, options);\n      }\n    } else if (tagType === TagType.SELF) {\n      if (currentNode && tag[14]) {\n        currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tag, options);\n      }\n\n      const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, '');\n      if (tag[8] && tag[8].length > 0) {\n        tag[8] = tag[8].substr(0, tag[8].length - 1);\n      }\n      childNode.attrsMap = buildAttributesMap(tag[8], options);\n      currentNode.addChild(childNode);\n    } else {\n      //TagType.OPENING\n      const childNode = new xmlNode(\n        options.ignoreNameSpace ? tag[7] : tag[5],\n        currentNode,\n        processTagValue(tag, options)\n      );\n      if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n        childNode.startIndex=tag.index + tag[1].length\n      }\n      childNode.attrsMap = buildAttributesMap(tag[8], options);\n      currentNode.addChild(childNode);\n      currentNode = childNode;\n    }\n\n    tag = nextTag;\n    nextTag = tagsRegx.exec(xmlData);\n  }\n\n  return xmlObj;\n};\n\nfunction processTagValue(parsedTags, options, parentTagName) {\n  const tagName = parsedTags[7] || parentTagName;\n  let val = parsedTags[14];\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n  }\n\n  return val;\n}\n\nfunction checkForTagType(match) {\n  if (match[4] === ']]>') {\n    return TagType.CDATA;\n  } else if (match[10] === '/') {\n    return TagType.CLOSING;\n  } else if (typeof match[8] !== 'undefined' && match[8].substr(match[8].length - 1) === '/') {\n    return TagType.SELF;\n  } else {\n    return TagType.OPENING;\n  }\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n  if (shouldParse && typeof val === 'string') {\n    let parsed;\n    if (val.trim() === '' || isNaN(val)) {\n      parsed = val === 'true' ? true : val === 'false' ? false : val;\n    } else {\n      if (val.indexOf('0x') !== -1) {\n        //support hexa decimal\n        parsed = Number.parseInt(val, 16);\n      } else if (val.indexOf('.') !== -1) {\n        parsed = Number.parseFloat(val);\n        val = val.replace(/0+$/,\"\");\n      } else {\n        parsed = Number.parseInt(val, 10);\n      }\n      if (parseTrueNumberOnly) {\n        parsed = String(parsed) === val ? parsed : val;\n      }\n    }\n    return parsed;\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.parseTrueNumberOnly\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;\n","'use strict';\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst doesMatch = function(string, regex) {\n  const match = regex.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nconst doesNotMatch = function(string, regex) {\n  return !doesMatch(string, regex);\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if(arrayMode === 'strict'){\n        target[keys[i]] = [ a[keys[i]] ];\n      }else{\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options, defaultOptions, props) {\n  var newOptions = {};\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n  return newOptions;\n};\n\nexports.doesMatch = doesMatch;\nexports.doesNotMatch = doesNotMatch;\nexports.getAllMatches = getAllMatches;\n","'use strict';\n\nconst nodeToJson = require('./node2json');\nconst xmlToNodeobj = require('./xmlstr2xmlnode');\nconst x2xmlnode = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\nconst validator = require('./validator');\n\nexports.parse = function(xmlData, options, validationOption) {\n  if( validationOption){\n    if(validationOption === true) validationOption = {}\n    \n    const result = validator.validate(xmlData, validationOption);\n    if (result !== true) {\n      throw Error( result.err.msg)\n    }\n  }\n  options = buildOptions(options, x2xmlnode.defaultOptions, x2xmlnode.props);\n  return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options), options);\n};\nexports.convertTonimn = require('../src/nimndata').convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require('./node2json_str').convertToJsonString;\nexports.validate = validator.validate;\nexports.j2xParser = require('./json2xml');\nexports.parseToNimn = function(xmlData, schema, options) {\n  return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);\n};\n"],"sourceRoot":""}