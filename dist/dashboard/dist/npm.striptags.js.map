{"version":3,"sources":["webpack:////home/v0idnull/Github/master-dashboard/node_modules/striptags/src/striptags.js"],"names":["global","Symbol","name","nonNative","STATE_PLAINTEXT","STATE_HTML","STATE_COMMENT","ALLOWED_TAGS_REGEX","NORMALIZE_TAG_REGEX","striptags","html","allowable_tags","tag_replacement","striptags_internal","init_context","tag_set","Set","match","exec","add","iterator","forEach","parse_allowable_tags","state","tag_buffer","depth","in_quote_char","context","output","idx","length","char","has","normalize_tag","slice","toLowerCase","init_streaming_mode"],"mappings":"0FAAA,OAEC,SAAUA,GAGP,GAAsB,mBAAXC,EAAuB,CAC9B,IAAIA,EAAS,SAASC,GAClB,OAAOA,GAGXD,EAAOE,WAAY,EAGvB,MAAMC,EAAkBH,EAAO,aACzBI,EAAkBJ,EAAO,QACzBK,EAAkBL,EAAO,WAEzBM,EAAsB,WACtBC,EAAsB,kBAE5B,SAASC,EAAUC,EAAMC,EAAgBC,GAOrC,OAAOC,EANPH,EAAkBA,GAAQ,GAIZI,EAHdH,EAAkBA,GAAkB,GACpCC,EAAkBA,GAAmB,KAoBzC,SAASE,EAAaH,EAAgBC,GAGlC,MAAO,CACHD,eAHJA,EAiJJ,SAA8BA,GAC1B,IAAII,EAAU,IAAIC,IAElB,GAA8B,iBAAnBL,EAA6B,CACpC,IAAIM,EAEJ,KAAQA,EAAQV,EAAmBW,KAAKP,IACpCI,EAAQI,IAAIF,EAAM,SAIhBhB,EAAOE,WACmC,mBAApCQ,EAAeV,EAAOmB,UAKK,mBAA3BT,EAAeU,SAE3BV,EAAeU,QAAQN,EAAQI,IAAKJ,GALpCA,EAAU,IAAIC,IAAIL,GAQtB,OAAOI,EAvKUO,CAAqBX,GAIlCC,gBAAiBA,EAEjBW,MAAgBnB,EAChBoB,WAAgB,GAChBC,MAAgB,EAChBC,cAAgB,IAIxB,SAASb,EAAmBH,EAAMiB,GAC9B,IAAIhB,EAAkBgB,EAAQhB,eAC1BC,EAAkBe,EAAQf,gBAE1BW,EAAgBI,EAAQJ,MACxBC,EAAgBG,EAAQH,WACxBC,EAAgBE,EAAQF,MACxBC,EAAgBC,EAAQD,cACxBE,EAAgB,GAEpB,IAAK,IAAIC,EAAM,EAAGC,EAASpB,EAAKoB,OAAQD,EAAMC,EAAQD,IAAO,CACzD,IAAIE,EAAOrB,EAAKmB,GAEhB,GAAIN,IAAUnB,EACV,OAAQ2B,GACJ,IAAK,IACDR,EAAclB,EACdmB,GAAcO,EACd,MAEJ,QACIH,GAAUG,OAKjB,GAAIR,IAAUlB,EACf,OAAQ0B,GACJ,IAAK,IAED,GAAIL,EACA,MAIJD,IACA,MAEJ,IAAK,IAED,GAAIC,EACA,MAIJ,GAAID,EAAO,CACPA,IAEA,MAIJC,EAAgB,GAChBH,EAAgBnB,EAChBoB,GAAgB,IAEZb,EAAeqB,IAAIC,EAAcT,IACjCI,GAAUJ,EAEVI,GAAUhB,EAGdY,EAAa,GACb,MAEJ,IAAK,IACL,IAAK,IAIGE,EADAK,IAASL,EACO,GAEAA,GAAiBK,EAGrCP,GAAcO,EACd,MAEJ,IAAK,IACkB,QAAfP,IACAD,EAAQjB,GAGZkB,GAAcO,EACd,MAEJ,IAAK,IACL,IAAK,KACD,GAAmB,MAAfP,EAAoB,CACpBD,EAAanB,EACbwB,GAAa,KACbJ,EAAa,GAEb,MAGJA,GAAcO,EACd,MAEJ,QACIP,GAAcO,OAKrB,GAAIR,IAAUjB,EACf,OAAQyB,GACJ,IAAK,IAC2B,MAAxBP,EAAWU,OAAO,KAElBX,EAAQnB,GAGZoB,EAAa,GACb,MAEJ,QACIA,GAAcO,GAY9B,OALAJ,EAAQJ,MAAgBA,EACxBI,EAAQH,WAAgBA,EACxBG,EAAQF,MAAgBA,EACxBE,EAAQD,cAAgBA,EAEjBE,EA4BX,SAASK,EAAcT,GACnB,IAAIP,EAAQT,EAAoBU,KAAKM,GAErC,OAAOP,EAAQA,EAAM,GAAGkB,cAAgB,KAhL5C1B,EAAU2B,oBAXV,SAA+BzB,EAAgBC,GAI3C,IAAIe,EAAUb,EAHdH,EAAkBA,GAAkB,GACpCC,EAAkBA,GAAmB,IAIrC,OAAO,SAA0BF,GAC7B,OAAOG,EAAmBH,GAAQ,GAAIiB,UAyLY,KAAtD,aAAmC,OAAOlB,GAAY,8BA5N9D","file":"dist/npm.striptags.js","sourcesContent":["'use strict';\n\n(function (global) {\n\n    // minimal symbol polyfill for IE11 and others\n    if (typeof Symbol !== 'function') {\n        var Symbol = function(name) {\n            return name;\n        }\n\n        Symbol.nonNative = true;\n    }\n\n    const STATE_PLAINTEXT = Symbol('plaintext');\n    const STATE_HTML      = Symbol('html');\n    const STATE_COMMENT   = Symbol('comment');\n\n    const ALLOWED_TAGS_REGEX  = /<(\\w*)>/g;\n    const NORMALIZE_TAG_REGEX = /<\\/?([^\\s\\/>]+)/;\n\n    function striptags(html, allowable_tags, tag_replacement) {\n        html            = html || '';\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return striptags_internal(html, context);\n    }\n\n    function init_striptags_stream(allowable_tags, tag_replacement) {\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return function striptags_stream(html) {\n            return striptags_internal(html || '', context);\n        };\n    }\n\n    striptags.init_streaming_mode = init_striptags_stream;\n\n    function init_context(allowable_tags, tag_replacement) {\n        allowable_tags = parse_allowable_tags(allowable_tags);\n\n        return {\n            allowable_tags : allowable_tags,\n            tag_replacement: tag_replacement,\n\n            state         : STATE_PLAINTEXT,\n            tag_buffer    : '',\n            depth         : 0,\n            in_quote_char : ''\n        };\n    }\n\n    function striptags_internal(html, context) {\n        let allowable_tags  = context.allowable_tags;\n        let tag_replacement = context.tag_replacement;\n\n        let state         = context.state;\n        let tag_buffer    = context.tag_buffer;\n        let depth         = context.depth;\n        let in_quote_char = context.in_quote_char;\n        let output        = '';\n\n        for (let idx = 0, length = html.length; idx < length; idx++) {\n            let char = html[idx];\n\n            if (state === STATE_PLAINTEXT) {\n                switch (char) {\n                    case '<':\n                        state       = STATE_HTML;\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        output += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_HTML) {\n                switch (char) {\n                    case '<':\n                        // ignore '<' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // we're seeing a nested '<'\n                        depth++;\n                        break;\n\n                    case '>':\n                        // ignore '>' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // something like this is happening: '<<>>'\n                        if (depth) {\n                            depth--;\n\n                            break;\n                        }\n\n                        // this is closing the tag in tag_buffer\n                        in_quote_char = '';\n                        state         = STATE_PLAINTEXT;\n                        tag_buffer   += '>';\n\n                        if (allowable_tags.has(normalize_tag(tag_buffer))) {\n                            output += tag_buffer;\n                        } else {\n                            output += tag_replacement;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    case '\"':\n                    case '\\'':\n                        // catch both single and double quotes\n\n                        if (char === in_quote_char) {\n                            in_quote_char = '';\n                        } else {\n                            in_quote_char = in_quote_char || char;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case '-':\n                        if (tag_buffer === '<!-') {\n                            state = STATE_COMMENT;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case ' ':\n                    case '\\n':\n                        if (tag_buffer === '<') {\n                            state      = STATE_PLAINTEXT;\n                            output    += '< ';\n                            tag_buffer = '';\n\n                            break;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_COMMENT) {\n                switch (char) {\n                    case '>':\n                        if (tag_buffer.slice(-2) == '--') {\n                            // close the comment\n                            state = STATE_PLAINTEXT;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n        }\n\n        // save the context for future iterations\n        context.state         = state;\n        context.tag_buffer    = tag_buffer;\n        context.depth         = depth;\n        context.in_quote_char = in_quote_char;\n\n        return output;\n    }\n\n    function parse_allowable_tags(allowable_tags) {\n        let tag_set = new Set();\n\n        if (typeof allowable_tags === 'string') {\n            let match;\n\n            while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {\n                tag_set.add(match[1]);\n            }\n        }\n\n        else if (!Symbol.nonNative &&\n                 typeof allowable_tags[Symbol.iterator] === 'function') {\n\n            tag_set = new Set(allowable_tags);\n        }\n\n        else if (typeof allowable_tags.forEach === 'function') {\n            // IE11 compatible\n            allowable_tags.forEach(tag_set.add, tag_set);\n        }\n\n        return tag_set;\n    }\n\n    function normalize_tag(tag_buffer) {\n        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);\n\n        return match ? match[1].toLowerCase() : null;\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(function module_factory() { return striptags; });\n    }\n\n    else if (typeof module === 'object' && module.exports) {\n        // Node\n        module.exports = striptags;\n    }\n\n    else {\n        // Browser\n        global.striptags = striptags;\n    }\n}(this));\n"],"sourceRoot":""}